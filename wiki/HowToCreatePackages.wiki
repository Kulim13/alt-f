#summary How to Create Disk Installable Packages

{{{

*Work in progress, Not yet finished, spellchecked, reviewed, ...*

In order to follow the procedures outlined in this page, you must be able to build
Alt-F yourself, so start with the HowToBuild wiki page.

Creating Disk Installable Packages, or packages, as they will be called from here on,
is a two step process.

A-setup a BuildRoot package
===========================

Writing a package/<pkg_name>/<pkg_name>.mk makefile and a package/<pkg_name>/Configure.in configuration file.

You have to add the new package to package/Config.in

There are two kinds of BuildRoot packages:
	-autotools based packages, whose makefiles are very easy to write -- you should always try this first, if the package has a configure script;
	-a normal package, where you must write the rules of a set of well defined targets

In docs/buildroot.html you will find some details about this process, but only
covers the trivial (demo) situations.
Take a look at packages/Makefile.autotools.in -- the initial comments are worth
reading, and you will understand the targets that you must write and the available
hooks.
And, of course, look at the examples in the packages directory.

To help you write and test the package makefile, without doing a full build (and
if you want) without installing the package in the root filesystem, there are some
 non-obvious target that you can use at the command line:

	make O=$BLDDIR pkgname-source
	make O=$BLDDIR pkgname-configure
	make O=$BLDDIR pkgname-build
	make O=$BLDDIR pkgname-install
	make O=$BLDDIR pkgname

But this subject is out of scope.

B-Setup a Alt-F package
=======================

In this step you have to know the list of files of your package, and this
is the most difficult step.

Fortunatelly enough the mkpkg.sh scripy simplifies things a lot:

# ./mkpkg.sh 
usage: mkpkg.sh <package> |
        -rm <package> (remove from rootfs files from <pkg> |
        -ls <package> (list package file contents) |
        -set (store current rootfs file list) |
        -clean (remove new files since last -set) |
        -diff (show new files since last -set) |
        -force <package> (force create package. You must first create the .control file) |
        -setroot (creates rootfs base file list) |
        -cleanroot (remove all files not in rootfs base file list) |
        -index (create ipkg package index) |
        -all (recreates all packages in ipkfiles dir) |
        -help

Before starting step A above, and after doing a full build, with a clean and ready
root filesystem, you should run

	./mkpkg.sh -setroot

This creates a file with the contents of the rootfs for future use,
and is a definitive reference. You should next run

	./mkpkg.sh -set

that does the same thing, using a different file, but has a more transient state.

You should then configure BuildRoot with your new package, procedure A above, 
and do the usual

	make O=$BLDDIR

At the end,

	./mkpkg.sh -diff

shows you the new files in the rootfs since the last "-set". If it is not OK, do

	./mkpkg.sh -clean

and the new files will be deleted from the rootfs, as a "-diff" will show you.

After cycling over -diff and -clean and the package makefile, you are ready to
create the package filelist and description. For that execute

	./mkpkg.sh pkgname

This creates two files in the ipkgfiles directory, pkgname.lst and pkgname.control,
and in the pkgs directory the package itself, pkgname_version_arm.ipk

You should verify that pkgname.lst contains the desired package files, and you should
 edit pkgname.control, fixing the package descrition, the correct URL source,
and the correct dependencies. You should than do again a

	./mkpkg.sh pkgname

This is basically all. If you want to make the package available for others to
install, using a http accesible directory, you should also run

	./mkpkg.sh -index

that creates a Packages file in the pkgs directory.
If you now copy the *.ipk and Packages file to an http accessible directory and
announce its URL, you have just created a "feed" that others can use.

The dependencies line in the pkgname.control file is very importante. It should
contain a coma separated list of packages that this package depends on.
ipkg, which is the Alt-F package manager, first recursively installs the dependencies
packages, and only after that the new desired package.

You know the dependencies because you had to specify then in the package makefile
and Config.in. mkpkg.sh extracts that info from these files, but it is often incomplete.

There are other control files: pkgname.{postinst|postrm|conffiles|...} that are
executable shell scripts to be run after an install or removal.

For more details on those, look at the examples and also at

http://handhelds.org/moin/moin.cgi/Ipkg
http://handhelds.org/moin/moin.cgi/BuildingIpkgs
http://buffalo.nas-central.org/wiki/Overview_of_the_ipkg_package_management_system

Configuring packages
====================

If your package offers some kind of services that the user might want to start,
stop or customize, and you want to integrate these functionalities in the administrative web pages, there are some further steps you should follow.

Creating special package users, groups and directories
------------------------------------------------------

After a package is installed by the ipkg package manager, if a file named
<pkgname>.postinst is found, it is executed. As an example, here is the minidlna
post install script:

  #!/bin/sh

  addgroup -S -g 80 multimedia
  adduser -S -g "minidlna daemon" -G multimedia -u 11 -h /var/lib/minidlna minidlna

  chown -R minidlna:multimedia /etc/minidlna.conf
  ln -sf /usr/sbin/rcscript /sbin/rcminidlna

It creates a system group called multimedia and a system user called minidlna,
creates the user home directory, that must be under /var/lib, and creates a shortcut
to the package init script.

At package removal time, a script called <pkgname>.postrm is executed, and must
undo the actions performed by the postinst script. An example:

  #!/bin/sh

  deluser minidlna
  delgroup multimedia
  rm -f /sbin/rcminidlna
  # rm the home directory, if it is appropriate
  # rm -rf /var/lib/minidlna

Starting and stopping a service
-------------------------------

To manage a service, an init script must be written. It must support at least two
actions: start and stop, to start and stop the services provided by the package.
The script should go to the /etc/init.d/ directory and have a name like Snn<pkgname>,
where nn is a two digit number that specifies the order of the script execution:
a script named S10foo is executed before a script called S11bar at startup,
and after S11bar at shutdown.
Scripts can have the same number if order between them is not important.

As an example, the S21sysctrl sysctrl script

  #!/bin/sh

  DESC="fan/temperature/buttons/sleep/MD Daemon"
  NAME=sysctrl
  TYPE=sys

  . $(dirname $0)/common

  case "$1" in
        start) start $NAME ;;
        stop)   stop $NAME ;;
        status) status $NAME ;;
        reload) reload $NAME ;;
        restart) restart $NAME ;;
        *)  usage $0 "start|stop|status|restart|reload" ;;
  esac

supports the start, stop, status, restart and reload actions, and as such can be
called from the command line as "/etc/init.d/S21sysctrl start" or
"/etc/init.d/S21sysctrl stop".
To avoid the need to remember (and type) all that, shortcuts in the form "rc<pkgname>"
must exist, enabling the usage of "rcsysctrl start". Usually such shortcuts are
created at install time by the <pkgname>.postinst script using the
/usr/sbin/rcscript utility script.

Init scripts can use some utility functions defined in the file /etc/init.d/common.
The start action launches the process specified in the NAME line, the restart action
stops the process, waits until it has finished, and
starts it again; "reload" send a sighup to the process, and can be used
to signal the process that a configuration change has happened (if the service process
can deal with it, not all can), and "status" checks if the process is running.
If the init scrip has execute permissions it will be automatically started
at boot time.

Using the Services web pages
----------------------------

If a line with "TYPE=<sys|user|net>" exists in the initscript, than its name, current
status and the content of the DESC line are shown in the corresponding Service web
page, together with a button that allows the user to start or stop the service.
The administrative web page allows setting a service to start at boot
time by checking the corresponding "Boot enable" checkbutton and submiting.

Configuring the service using a web page
----------------------------------------

If a file named <pkgname>.cgi exists in the /usr/www/cgi-bin directory, and is
executable, then a Configure button will appear in the Services web page, executing
the script when clicked.
The script must be sh based, and by convention a script called <pkgname>_proc.cgi,
also sh based and executable, should be called when the form is submited.
Writting sh based cgi scripts is behind the scope of this document. As a simple
example, see the /usr/www/cgi-bin/hosts.cgi script.

}}}